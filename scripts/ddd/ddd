#!/bin/bash

# Must use bash 4.0+

# ddd - The Dynamic Disk Destroyer


# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
IFS=$'\n\t'


TMP_ROOT="/tmp/"
DDD_SUBDIR="ddd_data"

TMP_DIR=${TMP_ROOT}/${DDD_SUBDIR}
DDD_MAP="${TMP_DIR}/mappings"

DEFAULT_LOCK="${TMP_DIR}/ddd_lock"

DD_ARGS="status=none"

SLP_TIME=0.5
export ACTION='invalid'

# Map to hold usb -> pid mappings
declare -A USB_MAP
# Squelch not defined errors by adding a map.
USB_MAP[nil]="nil"

usage() {
	cat <<EOF
ddd - The Dynamic Disk Destroyer

Usage:
ddd start [inFile] [outFile]
ddd status [outFile]

inFile and outFile are only needed if you specify start
EOF
}

# Aquires a lock. Give it a path to a lock file (that dosen't exist yet)
# mkdir(1) should be atomic. On most computers at least.
aquire() {
	LK=${1:-$DEFAULT_LOCK}
	# TODO redirect output of mkdir to prevent false output.
	while ! mkdir ${LK}; do
		sleep ${SLP_TIME}
	done
	# Lock was aquired, continue.
}

# Releases a lock file
# Does not fail if lock was not aquired.
release() {
	LK=${1:-$DEFAULT_LOCK}
	rm -rf ${LK}
}

parse_args() {
	if [ "$#" -lt 1 ]; then
		usage
		exit 1
	fi

	case $1 in
		start)
			if [ "$#" -lt 3 ]; then
				usage
				exit 1
			fi
			export INFILE="$2"
			export OUTFILE="$3"
			export ACTION='start'
			;;
		status)
			if [ "$#" -lt 2 ]; then
				usage
				exit 1
			fi
			export OUTFILE="$2"
			export ACTION='status'
			;;
		*)
			usage >&2
			exit 1
			;;
	esac
}

restore_mapping() {
	# Create our tmp dir if we haven't already
	mkdir -p ${TMP_DIR}

	# If we have stored USB_MAP, reload it
	if [ -f ${DDD_MAP} ]; then
		source ${DDD_MAP}
	fi
}

save_mapping() {
	# Create our tmp dir if we haven't already
	mkdir -p ${TMP_DIR}

	# Write USB_MAP to tmp file
	declare -p USB_MAP > ${DDD_MAP}
}

check_bash_version() {
	# Check to see if we have a suitable version of bash (for maps)
	if [ "$(echo "$BASH_VERSION" | awk -F. '{ print $1 }')" -lt 4 ]; then
		echo "ddd requires bash > 4.0. Exiting." >&2
		exit 1
	fi
}

# Function to be forked off that manages running dd, and reporting failure status back to the hashmap
# @param inFile
# @param outFile
run_dd() {
	INFILE="${1:-$INFILE}"
	OUTFILE="${2:-$OUTFILE}"

	OUTPUT=$'\n'

	set +e
	# Report back to us once every 5 seconds with a 0->100 percentage
	(stdbuf -oL pv -i 5 -p -n ${INFILE} | dd ${DD_ARGS:-} of=${OUTFILE}) 2>&1 | {
		while IFS= read -r line; do
			# Check if we have a naked number
			if  echo "$line" | grep -Eqo '^[0-9]+$'; then
				# Write results of dd run to map
				aquire
				restore_mapping

				USB_MAP[$OUTFILE]="p$line"

				save_mapping
				release
			else
				# Log for storage later
				OUTPUT="$OUTPUT"$'\n'"$line"
			fi
		done
		RET="$?"
		set -e

		# Write results of dd run to map
		aquire
		restore_mapping

		USB_MAP[$OUTFILE]="c${RET}$OUTPUT"

		save_mapping
		release
	}
}

# status() {
# }

start() {
	# Force start at 0 progress
	aquire
	restore_mapping
	USB_MAP[$OUTFILE]="p0"
	save_mapping
	release

	run_dd $INFILE $OUTFILE &
}

main() {
	check_bash_version

	parse_args "$@"

	# TODO remove, this is for testing
	start
}

main "$@"
