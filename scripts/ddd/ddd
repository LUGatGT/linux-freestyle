#!/usr/bin/env bash

# Must use bash 4.0+

# ddd - The Dynamic Disk Destroyer


# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
IFS=$'\n\t'


TMP_ROOT="/tmp/"
DDD_SUBDIR="ddd_data"

TMP_DIR=${TMP_ROOT}/${DDD_SUBDIR}
DDD_MAP="${TMP_DIR}/mappings"

DEFAULT_LOCK="${TMP_DIR}/ddd_lock"

DD_ARGS="status=none"

SLP_TIME=0.5
export ACTION='invalid'

EXIT_NOT_FOUND=100
EXIT_FAILED_WRITE=101
EXIT_ALREADY_RUNNING=200
EXIT_INTERNAL_ERR=1

# Map to hold usb -> pid mappings
declare -A USB_MAP
# Squelch not defined errors by adding a map.
USB_MAP[nil]="nil"

usage() {
	cat <<EOF
ddd - The Dynamic Disk Destroyer

Usage:
ddd start [inFile] [outFile]
ddd status [outFile]

inFile and outFile are only needed if you specify start
EOF
}

# Aquires a lock. Give it a path to a lock file (that dosen't exist yet)
# mkdir(1) should be atomic. On most computers at least.
aquire() {
	LK=${1:-$DEFAULT_LOCK}
	# TODO redirect output of mkdir to prevent false output.
	while ! mkdir ${LK} >/dev/null 2>&1; do
		sleep ${SLP_TIME}
	done
	# Lock was aquired, continue.
}

# Releases a lock file
# Does not fail if lock was not aquired.
release() {
	LK=${1:-$DEFAULT_LOCK}
	rm -rf ${LK}
}

parse_args() {
	if [ "$#" -lt 1 ]; then
		usage
		exit ${EXIT_INTERNAL_ERR}
	fi

	case $1 in
		start)
			if [ "$#" -lt 3 ]; then
				usage
				exit ${EXIT_INTERNAL_ERR}
			fi
			export INFILE="$2"
			export OUTFILE="$3"
			export ACTION='start'
			;;
		status)
			if [ "$#" -lt 2 ]; then
				usage
				exit ${EXIT_INTERNAL_ERR}
			fi
			export OUTFILE="$2"
			export ACTION='status'
			;;
		*)
			usage >&2
			exit ${EXIT_INTERNAL_ERR}
			;;
	esac
}

restore_mapping() {
	# Create our tmp dir if we haven't already
	mkdir -p ${TMP_DIR}

	# If we have stored USB_MAP, reload it
	if [ -f ${DDD_MAP} ]; then
		source ${DDD_MAP}
		for key in "${!USB_MAP_TMP[@]}"
		do
			USB_MAP["$key"]="${USB_MAP_TMP["$key"]}"
		done
	fi
}

save_mapping() {
	# Create our tmp dir if we haven't already
	mkdir -p ${TMP_DIR}

	# Write USB_MAP to tmp file
	declare -p USB_MAP | sed "s/USB_MAP/USB_MAP_TMP/g" > ${DDD_MAP}
}

check_bash_version() {
	# Check to see if we have a suitable version of bash (for maps)
	if [ "$(echo "$BASH_VERSION" | awk -F. '{ print $1 }')" -lt 4 ]; then
		echo "ddd requires bash > 4.0. Exiting." >&2
		exit ${EXIT_INTERNAL_ERR}
	fi
}

# Function to be forked off that manages running dd, and reporting failure status back to the hashmap
# @param inFile
# @param outFile
run_dd() {
	INFILE="${1:-$INFILE}"
	OUTFILE="${2:-$OUTFILE}"

	OUTPUT=""

	set +e
	# Report back to us once every 5 seconds with a 0->100 percentage
	# This weirdness let's us read the OUTPUT variable in the braces, as well as the return code of dd, and process dd output line by line
	# http://unix.stackexchange.com/questions/117501/in-bash-script-how-to-capture-stdout-line-by-line
	# This runs in a subshell so we need to do this to extract all the data we need.
	OUTPUT=$((stdbuf -oL pv -i 5 -p -n ${INFILE} | dd ${DD_ARGS:-} of=${OUTFILE}) 2>&1 | {
				 while IFS= read -r line; do
					 # Check if we have a naked number
					 if  echo "$line" | grep -Eqo '^[0-9]+$'; then
						 # Write results of dd run to map
						 aquire
						 restore_mapping

						 USB_MAP[$OUTFILE]="p$line"

						 save_mapping
						 release
					 else
						 # Log for storage later
						 export OUTPUT="$OUTPUT"$'\n'"$line"
					 fi
				 done
				 echo "$OUTPUT"
			 })
	RET="$?"
	set -e

	# Write results of dd run to map
	aquire
	restore_mapping

	USB_MAP[$OUTFILE]="c${RET}$OUTPUT"

	save_mapping
	release

	# echo "$?"
}

status() {
	aquire
	restore_mapping
	release

	STATUS="${USB_MAP[$OUTFILE]:-}"
	if [ -z "$STATUS" ]; then
		echo "no job found" >&2
		exit $EXIT_NOT_FOUND
	fi

	if echo "$STATUS" | grep -Eq '^p[0-9]+$'; then
		# In progress
		echo "$STATUS" | grep -Eo '[0-9]+'
	elif echo "$STATUS" | grep -Eq '^c[0-9]+'; then
		# Finished
		if echo "$STATUS" | grep -Eqo '^c0'; then
			# Success
			echo "completed"
		else
			echo "failed"
			# Status code
			echo "$STATUS" | head -n 1 | grep -Eo '[0-9]+'
			# Error logs
			echo "$STATUS" | tail -n +2
			exit $EXIT_FAILED_WRITE
		fi
	fi
}

start() {
	# Force start at 0 progress
	aquire
	restore_mapping

	if echo "${USB_MAP[$OUTFILE]:-}" | grep -q '^p'; then
		# Something's already running
		release
		echo "job already running" >&2
		exit $EXIT_ALREADY_RUNNING
	fi

	USB_MAP[$OUTFILE]="p0"
	save_mapping
	release

	run_dd $INFILE $OUTFILE &
}

invalid() {
	echo >&2 "An Internal Error Occured!"
	exit ${EXIT_INTERNAL_ERR}
}

main() {
	# Create our tmp dir
	mkdir -p ${TMP_DIR}

	check_bash_version

	parse_args "$@"

	$ACTION
}

main "$@"
